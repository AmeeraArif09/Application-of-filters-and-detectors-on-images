# -*- coding: utf-8 -*-
"""dohelp.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1MX4BBzh8rSyh4KLvXk60iha6nBiql_dd
"""

# This Python 3 environment comes with many helpful analytics libraries installed
# It is defined by the kaggle/python Docker image: https://github.com/kaggle/docker-python
# For example, here's several helpful packages to load

import numpy as np # linear algebra
import pandas as pd # data processing, CSV file I/O (e.g. pd.read_csv)
import inspect
import os


import cv2
import os
import sys
import numpy as np
import matplotlib.pyplot as plt
from skimage.util import random_noise
from skimage import util,filters,feature
from scipy import ndimage
from scipy import signal
import scipy.ndimage.filters
from skimage import color


# Input data files are available in the read-only "../input/" directory
# For example, running this (by clicking run or pressing Shift+Enter) will list all files under the input directory

import os

# You can write up to 20GB to the current directory (/kaggle/working/) that gets preserved as output when you create a version using "Save & Run All" 
# You can also write temporary files to /kaggle/temp/, but they won't be saved outside of the current session

"""Display image"""

def displayImage(image,title):
    plt.imshow(cv2.cvtColor(image,cv2.COLOR_BGR2RGB))
    plt.title(title)
    plt.show()

"""rgbExclusion function"""

# 0-b, 1-g, 2-r
def rgbExclusionRedChannel(image1):
    bgr_image = image1.copy()
    bgr_image[:,:,0] = 0 #empty blue channel
    bgr_image[:,:,1] = 0 #empty green channel
    # and we are left out with red channel
    displayImage(bgr_image,"Red Channel")

def rgbExclusionGreenChannel(image1):
    bgr_image = image1.copy()
    bgr_image[:,:,0] = 0 #empty blue channel
    bgr_image[:,:,2] = 0 #empty red channel
    # and we are left out with red channel
    displayImage(bgr_image,"Green Channel")

def rgbExclusionBlueChannel(image1):
    bgr_image = image1.copy()
    bgr_image[:,:,2] = 0 #empty red channel
    bgr_image[:,:,1] = 0 #empty green channel
    # and we are left out with red channel
    displayImage(bgr_image,"Blue Channel")

def makehisto(image1):
    # find frequency of pixels in range 0-255 
    histr = cv2.calcHist([image1],[0],None,[256],[0,256]) 
    # show the plotting graph of an image 
    plt.plot(histr) 
    plt.title('Histogram')
    plt.show()

def equalizedHistogram(image1):
    from skimage import exposure
    plt.title("Equalized image")
    # Adjust the contrast of the filtered image by applying Histogram Equalization 
    image_equalized = exposure.equalize_hist(image1)
    plt.imshow(image_equalized)
    #displayImage(image_equalized,"Actual image")
    #return image_equalized
    #makehisto(image_equalized)

def myConvolve2d(image, kernel):
    """
    In this function convolution operation is implemented from scratch
    # This function which takes an image and a kernel 
    # and returns the convolution of them
    # Args:
    #   image: a numpy array of size [image_height, image_width].
    #   kernel: a numpy array of size [kernel_height, kernel_width].
    # Returns:
    #   a numpy array of size [image_height, image_width] (convolution output).
    
    """
    kernel = np.flipud(np.fliplr(kernel))    # Flip the kernel
    output = np.zeros_like(image)            # convolution output
    # Add zero padding to the input image
    image_padded = np.zeros((image.shape[0] + 2, image.shape[1] + 2))   
    image_padded[1:-1, 1:-1] = image
    
    # Loop over every pixel of the image and implement convolution operation (element wise multiplication and summation). 
    # You can use two loops. The result is stored in the variable output.
    
    for x in range(image.shape[0]):     # Loop over every pixel of the image
        for y in range(image.shape[1]):
            # element-wise multiplication and summation 
            output[x,y]=(kernel*image_padded[x:x+3,y:y+3]).sum()
        
    
    return output

def first_dev_gaussian_x(x, y, sigma):
    temp = (x ** 2 + y ** 2) / (2 * sigma ** 2)
    return -x * np.exp(-temp)/ (2* np.pi * sigma ** 4) 
 
def first_dev_gaussian_y(x, y, sigma):

    temp = (x ** 2 + y ** 2) / (2 * sigma ** 2)
    return -y * np.exp(-temp)/ (2* np.pi * sigma ** 4)
 
def second_dev_gaussian_x(x, y, sigma):

    temp = (x ** 2 + y ** 2) / (2 * sigma ** 2)
    temp1 = np.exp(-temp) /(2* np.pi * sigma ** 4) 
    return (-1 + x**2 / sigma**2)* temp1
 
def second_dev_gaussian_y(x, y, sigma):

    temp = (x ** 2 + y ** 2) / (2 * sigma ** 2)
    temp1 = np.exp(-temp) /(2* np.pi * sigma ** 4) 
    return (-1 + y**2 / sigma**2)* temp1

def second_dev_gaussian(x, y, sigma):
    temp = (x ** 2 + y ** 2) / (2 * sigma ** 2)
    temp1 = np.exp(-temp) /(2* np.pi * sigma ** 4) 
    return (x * y / 2 * np.pi *sigma**6)* temp1

def gaussian(x, y, sigma):
    temp = (x ** 2 + y ** 2) / (2 * sigma ** 2)
    return (-1 * np.exp(-temp)/ (2* np.pi * sigma ** 2) )